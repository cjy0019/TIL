# 질문 대비

#### 1. 값이란?

- 값은 식, 즉 표현식이 평가되어 생성된 하나의 결과를 말합니다.

#### 2. 리터럴이란?

- 리터럴은 사람이 이해할 수 있는 문자 또는 기호를 사용해 값을 생성하는 표기 방식(notation)을 말한다.
- 자바스크립트 엔진은 코드가 실행되는 시점인 런타임에 리터럴을 평가해 값을 생성한다.

#### 3. 표현식이란?

- 표현식은 값으로 평가될 수 있는 문(statement)이다. 즉 표현식이 평가되면 값을 생성하거나 기존 값을 참조한다.
- 리터럴도 값으로 평가되기 때문에 리터럴도 표현식이다.

#### 4. 문이란?

- 문은 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다.
- 문은 여러 개의 토큰으로 구성된다. 토큰이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.
- 키워드, 식별자, 연산자, 리터럴, 세미콜론, 마침표는 문법적인 의미를 가지고 더 이상 나눌 수 없는 코드의 기본 요소이므로  토큰이다.
- 문은 명령문이라고도 불리는데 문이 실행되면 명령이 실행되고 무슨 일인가가 일어나기 때문이다.

#### 5. if문 for문 함수 코드 블록 뒤에는 세미콜론을 붙이지 않는 이유?

- 0개 이상의 문을 중괄호로 묶은 코드 블록 뒤에는 세미콜론을 붙이지 않는다.
- 이러한 코드 블록은 언제나 문의 종료를 의미하는 자체 종결성(self closing)을 갖기 때문이다.

#### 6. 세미콜론을 생략할 수 있는 이유는?

- 자바스크립트 엔진이 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 세미콜론 자동 삽입 기능(ASI, automatic semicolon insertion)이 암묵적으로 수행되기 때문이다.

#### 7. 표현식인 문과 표현식이 아닌 문

- 값으로 평가 될 수 있는 문과 값으로 평가 될 수 없는 문이다.
- 값으로 평가될 수 없다는 말은 변수의 값으로 쓸 수 없다는 말이다. 즉, 할당되어질 수 없다.
- 둘을 구별하기 위해서는 변수에 할당해보면 알 수 있다.

#### 8. 자바스크립트의 원시 타입과 객체 타입을 분류 해보시오.

- 원시 타입(primitive type)
  - 숫자(number) 타입
  - 문자열(string) 타입
  - 불리언(boolean) 타입
  - undefined 타입
  - null 타입
  - 심벌(symbol) 타입
- 객체 타입: 객체, 함수, 배열

#### 9. 자바스크립트의 숫자 타입의 크기는?

- 배정밀도 64비트 부동소수점 형식을 따르고 있다.
- 따라서 정수, 실수, 2진수, 8진수, 16진수 리터럴 모두 64비트 부동소수점 형식의 2진수로 저장된다.

#### 10. 숫자 타입의 세 가지 특별한 값은 무엇이 있나?

- Infinity
- -Infinity
- NaN : 산술 연산 불가

#### 11. 데이터의 타입이 필요한 이유는?

- 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해서
- 값을 참조할 떄 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해서
- 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해서

#### 12. 동적 타입 언어

- C, java 같은 언어들은 변수를 선언할 때 데이터 타입을 사전에 선언한다. 변수의 타입을 변경할 수 없고 변수에 선언한 타입의 값만 할당할 수 있다. 
- 그러나 자바스크립트는 정적 타입 언어와는 다르게 변수를 선언할 때 타입을 선언하지 않는다. var let const 키워드를 사용해 변수를 선언할 뿐이다. 자바스크립트에서는 값을 할당하는 시점에 변수의 타입이 동적으로 결정되고 변수의 타입을 언제든 자유롭게 변경할 수 있다.
- 자바스크립트는 변수 선언이 아닌 할당에 의해 타입이 결정된다. 그리고 재할당에 의해 타입은 언제든지 동적을 변할 수 있다.

#### 13. 동적 타입 언어의 단점은 무엇인가?

- 변수 값이 언제든지 변경될 수 있기 때문에 변화하는 변수 값 추적이 어려울 수 있다. 사용 전에 꼭 확인해야 한다.
- 자바스크립트 엔진에 의해 타입이 자동으로 변환되기도 하므로 신뢰성이 떨어진다.
- 이런 이유로 안정적인 프로그램을 만들기 위해 번거롭고 코드의 양도 증가하게 된다.