# 질문 대비

#### 1. 값이란?

- 값은 식, 즉 표현식이 평가되어 생성된 하나의 결과를 말합니다.

#### 2. 리터럴이란?

- 리터럴은 사람이 이해할 수 있는 문자 또는 기호를 사용해 값을 생성하는 표기 방식(notation)을 말한다.
- 자바스크립트 엔진은 코드가 실행되는 시점인 런타임에 리터럴을 평가해 값을 생성한다.

#### 3. 표현식이란?

- 표현식은 값으로 평가될 수 있는 문(statement)이다. 즉 표현식이 평가되면 값을 생성하거나 기존 값을 참조한다.
- 리터럴도 값으로 평가되기 때문에 리터럴도 표현식이다.

#### 4. 문이란?

- 문은 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다.
- 문은 여러 개의 토큰으로 구성된다. 토큰이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.
- 키워드, 식별자, 연산자, 리터럴, 세미콜론, 마침표는 문법적인 의미를 가지고 더 이상 나눌 수 없는 코드의 기본 요소이므로  토큰이다.
- 문은 명령문이라고도 불리는데 문이 실행되면 명령이 실행되고 무슨 일인가가 일어나기 때문이다.

#### 5. if문 for문 함수 코드 블록 뒤에는 세미콜론을 붙이지 않는 이유?

- 0개 이상의 문을 중괄호로 묶은 코드 블록 뒤에는 세미콜론을 붙이지 않는다.
- 이러한 코드 블록은 언제나 문의 종료를 의미하는 자체 종결성(self closing)을 갖기 때문이다.

#### 6. 세미콜론을 생략할 수 있는 이유는?

- 자바스크립트 엔진이 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 세미콜론 자동 삽입 기능(ASI, automatic semicolon insertion)이 암묵적으로 수행되기 때문이다.

#### 7. 표현식인 문과 표현식이 아닌 문

- 값으로 평가 될 수 있는 문과 값으로 평가 될 수 없는 문이다.
- 값으로 평가될 수 없다는 말은 변수의 값으로 쓸 수 없다는 말이다. 즉, 할당되어질 수 없다.
- 둘을 구별하기 위해서는 변수에 할당해보면 알 수 있다.

#### 8. 자바스크립트의 원시 타입과 객체 타입을 분류 해보시오.

- 원시 타입(primitive type)
  - 숫자(number) 타입
  - 문자열(string) 타입
  - 불리언(boolean) 타입
  - undefined 타입
  - null 타입
  - 심벌(symbol) 타입
- 객체 타입: 객체, 함수, 배열

#### 9. 자바스크립트의 숫자 타입의 크기는?

- 배정밀도 64비트 부동소수점 형식을 따르고 있다.
- 따라서 정수, 실수, 2진수, 8진수, 16진수 리터럴 모두 64비트 부동소수점 형식의 2진수로 저장된다.

#### 10. 숫자 타입의 세 가지 특별한 값은 무엇이 있나?

- Infinity
- -Infinity
- NaN : 산술 연산 불가

#### 11. 데이터의 타입이 필요한 이유는?

- 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해서
- 값을 참조할 떄 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해서
- 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해서

#### 12. 동적 타입 언어

- C, java 같은 언어들은 변수를 선언할 때 데이터 타입을 사전에 선언한다. 변수의 타입을 변경할 수 없고 변수에 선언한 타입의 값만 할당할 수 있다. 
- 그러나 자바스크립트는 정적 타입 언어와는 다르게 변수를 선언할 때 타입을 선언하지 않는다. var let const 키워드를 사용해 변수를 선언할 뿐이다. 자바스크립트에서는 값을 할당하는 시점에 변수의 타입이 동적으로 결정되고 변수의 타입을 언제든 자유롭게 변경할 수 있다.
- 자바스크립트는 변수 선언이 아닌 할당에 의해 타입이 결정된다. 그리고 재할당에 의해 타입은 언제든지 동적을 변할 수 있다.

#### 13. 동적 타입 언어의 단점은 무엇인가?

- 변수 값이 언제든지 변경될 수 있기 때문에 변화하는 변수 값 추적이 어려울 수 있다. 사용 전에 꼭 확인해야 한다.
- 자바스크립트 엔진에 의해 타입이 자동으로 변환되기도 하므로 신뢰성이 떨어진다.
- 이런 이유로 안정적인 프로그램을 만들기 위해 번거롭고 코드의 양도 증가하게 된다.

#### 14. 이항 산술 연산자와 단항 산술 연산자의 가장 큰 차이점은?

- 단항 산술 연산자는 피연산자의 값을 변경하는 부수 효과가 있다는 점이다.
- 다시 말해, 증가/감소 연산을 하면 피연산자의 값을 변경하는 암묵적 할당이 이뤄진다.

#### 15. 문자열 연결 연산자로 동작하는 조건

- +연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.
- 이 외의 경우는 산술 연산자로 동작한다.

#### 16. 동등 / 일치 비교 연산자

- 동등 비교(==) 연산자는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후, 같은 값인지 비교한다.
- 따라서 동등 비교 연산자는 좌항과 우항의 피연산자가 타입은 다르더라도 암묵적 타입 변환 후에 같은 값일 수 있다면 `ture`를 반환한다.
- 일치 비교(===) 연산자는 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 `true`를 반환한다.

```javascript
NaN === NaN; // false

isNaN(NaN); // true
isNaN(10); // false

0 === -0; // true
0 == -0 // true
Object.is(-0, +0);
Object.is(NaN, NaN);
```

#### 17. 드 모르간의 법칙을 사용해서 다음을 변환하시오.

```javascript
// 1번
!(x || y)

// 2번
!(x && y)
```

```javascript
// 1번 답
(!x && !y)

// 2번 답
(!x || !y)
```

#### 18. typeof null의 값은 무엇이며 null 값인지 확인하기 위한 코드를 작성하시오.

- `typeof null`의 값은 `null`이 아닌 `object`이다. 이는 자바스크립트의 첫 번째 버전의 버그이다.
- 따라서 `null`타입의 값인지 확인할 때는 `typeof`연산자가 아닌 `===`를 사용해야 한다.

```javascript
var foo = null;

typeof foo; // object
typeof foo === null; // false
foo === null; //true
```

#### 19. 지수 연산을 하는 방법 2가지

```javascript
2 ** 2; // 4
2 ** 0; // 1
2**2**2; // 16

Math.pow(2,2);
Math.pow(2,0);
Math.pow(Math.pow(2,2),2);
```

#### 20. switch Fall Through란?

- switch 문에서 case 내에서 의도적으로 break문을 생략하여 다음 case로 이동 시키는 방법
- 의도적으로 사용할 때도 있지만 그럴 떈 무조건 주석을 달아야 한다.

#### 21. 자바스크립트에서 Falsy 값으로 평가되는 값은?

- false, '', undefined, null, 0, -0, NaN

#### 22. 단축 평가란?

- 논리곱 연산자와 논리합 연산자는 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환한다.
- 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 말한다.

#### 23. 객체란?

- 객체 타입은 다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료구조를 의미한다.
- 객체는 변경 가능한 값이다.
- 객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키와 값으로 구성된다.

#### 24. 객체 리터럴의 중괄호 뒤에 세미콜론을 붙이는 이유는?

- 객체 리터럴의 중괄호는 코드 블록을 의미하지 않는다.
- 코드 블록의 뒤에는 자체 종결성 때문에 세미콜론을 붙이지 않는다.
- 하지만 객체 리터럴은 값으로 평가되는 표현식이다. 따라서 객체 리터럴의 닫는 중괄호 뒤에는 세미콜론을 붙인다.

#### 25. 프로그래밍 언어에서의 함수란?

- 함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.
- 함수는 입력을 받아서 출력을 내보낸다.
- 이 때, 함수 내부로 입력을 전달받는 변수를 매개변수(parameter), 입력을 인수(arguments), 출력을 반환 값(return value)이라고 한다.

#### 26. return문의 두 가지 기능은?

- 반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나간다. 따라서 반환문 이후에 다른 문이 존재하면 그 문은 실행되지 않고 무시된다.
- 반환문은 return 키워드 뒤에 오는 표현식을 평가해 반환한다.
- return 키워드 뒤에 반환 값으로 사용할 표현식을 명시적으로 지정하지 않으면 undefined가 반환된다.

#### 27.  원시값에 값을 재할당하면 어떻게 되는가?

- 메모리에 저장되어 있는 재할당 이전의 원시값을 변경하는 것이 아니고 새로운 메모리 공간을 확보한 후 새롭게 재할당한 원시값을 가리킨다.

- 변수가 참조하던 메모리 공간의 주소가 변경된 이유는 변수에 할당된 원시값이 변경 불가능한 값이기 때문이다.

#### 28. 얕은 복사와 깊은 복사의 차이

- 얕은 복사는 한 단계까지만 복사하는 것을 말한다.
- 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사한다.
- 원시값을 할당한 변수를 다른 변수에 할당하는 것을 깊은 복사, 객체를 할당한 변수를 다른 변수에 할당하는 것을 얕은 복사라고 부르기도 한다.

#### 29. JSON.parse(JSON.stringfy()) 를 이용하여 깊은 복사를 할 때 메서드가 사라지는 이유는?

- json 객체로 변환할 수 없는 것은 무시하기 떄문에

#### 30. 콜백함수와 고차함수란 무엇인가?

- 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수라 하며, 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수라고 한다.
- 매개변수를 통해 함수를 전달 받거나 반환값으로 함수를 반환하는 함수를 함수형 프로그래밍 패러다임에서 고차 함수라 한다.

#### 31. 순수 함수와 비순수 함수

- 함수형 프로그래밍에서는 어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 즉 부수 효과가 없는 함수를 순수 함수라 하고, 외부 상태에 의존하거나 외부 상태를 변경하는 즉 부수 효과가 있는 함수를 비순수 함수라고 한다. 
- 순수 함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수다. 즉, 순수 함수는 어떤 외부 상태에도 의존하지 않고 오직 매개변수를 통해 함수 내부로 전달된 인수에게만 의존해 반환 값을 만든다. 함수의 외부 상태에 의존하는 함수는 외부 상태에 따라 반환 값이 달라진다.
- 순수 함수의 또 하나의 특징은 함수의 외부 상태를 변경하지 않는다는 것이다. 

#### 32. 스코프란 무엇인가?

- 모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. 즉, 스코프는 식별자가 유효한 범위를 말한다.
- 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작해서 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.

#### 33. 타언어의 스코프와 자바스크립트의 var 스코프가 다른점은?

- C나 자바를 비롯한 대부분의 프로그래밍 언어는 함수 몸체만이 아니라 코드 블록이 지역 스코프를 만든다. 이러한 특성을 블록 레벨 스코프라 한다.
- 하지만 var 키워드로 선언된 변수는 오로지 함수의 코드 블록 만을  지역 스코프로 인정하는데 이를 함수 레벨 스코프라 한다.
- 자바스크립트는 렉시컬 스코프를 따르므로 함수를 어디서 호출했는지가 아니라 함수를 어디서 정의했는지에 따라 상위스코프를 결정한다. 함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않는다. 즉, 함수의 상위 스코프는 언제나 자신이 정의된 스코프이다.

#### 34. 생명주기란?

- 변수는 선언에 의해 생성되고 할당을 통해 값을 갖는다. 그리고 언젠간 소멸한다. 즉, 변수는 생물과 유사하게 생성되고 소멸되는 생명주기(life cycle)가 있다.

#### 35. 전역 변수의 문제점

- 암묵적 결합(모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합을 허용하는 것)
- 긴 생명 주기(전역 변수는 생명 주기가 길다. 따라서 메모리 리소스도 오랜 기간 소비한다)
- 스코프 체인 상에서 종점에 존재하기 떄문에 가장 마지막에 검색되기 떄문에 검색 속도가 느리다
- 네임스페이스 오염(파일이 분리되어 있더라도 전역 스코프를 공유하기 때문에 동일한 이름이 존재할 경우 예상치 못한 결과를 불러올 수 있다.)

#### 36. 전역 변수를 사용하지 않는 방법

- 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 **즉시 실행 함수**의 지역 변수가 된다.

- 전역에 **네임스페이스** 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법

- ```javascript
  var MYAPP = {};
  MYAPP.name = 'Lee'
  console.log(MYAPP.name); // LEE
  
  var MYAPP = {};
  MYAPP.person = {
      name : 'LEE',
      address : 'Seoul'
  };
  ```

- ES6 모듈을 사용하면 더는 전역 변수를 사용할 수 없다. ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다. 즉, 모듈 내에서 var 키워드로 선언한 변수는 더는 전역 변수가 아니고 window객체의 프로퍼티도 아니다.

#### 37. freeze를 이용하여 깊은 객체 동결하는 함수를 만들어라

```javascript
const deepFreeze = (target) => {
    if(target && typeof target === 'object' && !Object.isFrozen(target)){
        Object.freeze(target);
        Object.keys(target).forEach(key => deepFreeze(target[key]));
    }
    return target;
}
```

#### 38. 생성자 함수란 무엇인가?

- 생성자 함수란 new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말한다. 생성자 함수에 의해 생성된 객체를 인스턴스라고 한다.
- 객체 리터럴에 의한 객체 생성 방식은 직관적이고 간편하다. 하지만 객체 리터럴에 의한 객체 생성 방식은 하나의 객체만 생성한다.
- 생성자 함수에 의한 객체 생성 방식은 객체를 생성하기 위한 템플릿처럼 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다.

#### 39. 자바스크립트에서 객체를 생성하시는 방식은 무엇이 있는지 말해보라

- 객체리터럴
- Object 생성자 함수
- 생성자 함수

#### 40. new를 통해 호출되지 않은 경우를 대비해 new.target 과 스코프 세이프 생성자 패턴을 이용하여 코딩하여라.

```javascript
// new.target

function Circle(radius){
    if(!new.target) return new Circle(radius);
    
    this.radius = radius;
    this.getDiameter = function(){
        return this.radius * 2;
    }
}
```

```javascript
// 스코프 세이프 패턴(IE에서는 new.target이 동작하지 않는다)

function Circle(radius){
    if(!(this instanceOf Circle)) return new Circle(radius);
    
    this.radius = radius;
    this.getDiameter = function(){
        return this.radius * 2;
}

```

#### 41. 일급 객체를 만족시키는 조건은?

1. 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.
2. 변수나 자료구조에 저장할 수 있다.
3. 함수의 매개변수에 전달할 수 있다.
4. 함수의 반환값으로 사용할 수 있다.

#### 42. 일반 객체와는 달리 함수 객체만이 내부적으로 가지는 프로퍼티들은?

1. arguments 프로퍼티 - 함수 호출 시 전달된 인수의 정보를 담고 있다. length 프로퍼티를 가져 순회 가능한 유사 배열 객체이다. 인수를 전달할 때 초과된 함수들이 이 객체의 프로퍼티로 저장되고 **가변 인자 함수**를 구현할 때 유용하다. 하지만 최근에는 Rest파라미터로 인해 많이 사용하지는 않는다.
2. length 프로퍼티 - 함수가 정의될 때 선언된 파라미터의 개수를 가리킨다. arguments 객체의 length는 인수의 개수를 가리키는 반면 length 프로퍼티는 파라미터의 개수를 가리킨다.
3. name 프로퍼티 - 함수의 이름을 가리킨다.
4. prototype 프로퍼티 - constructor만이 소유하는 프로퍼티이다.

#### 43. 내부슬롯 [[Prototype]]에 저장되는 프로토타입은 어떻게 결정되는가?

- 모든 객체는 [[Prototype]]내부 슬롯을 가지는데 객체 리터럴에 의해 생성된 객체의 프로토타입은 Object.prototype이고 생성자 함수에 의해 생성된 객체의 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체이다.

#### 44. 프로토타입에서 프로퍼티 쉐도잉은 무엇인가?

- 프로토타입이 소유한 프로퍼티를 프로토타입 프로퍼티, 인스턴스가 소유한 프로퍼티를 인스턴스 프로퍼티라고 부르는데 **프로토타입 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가하면 프로토타입 프로퍼티를 덮어쓰지 않고 인스턴스 프로퍼티에 추가한다.**

#### 45. 오버라이딩?

- 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의하여 사용하는 방식이다.

#### 46. instanceOf 메서드란?

- 생성자 함수의 prototype에 바인딩된 객체가 프로토타입 체인 상에 존재하는지 확인하는 메서드

#### 47. Object.keys/values/entries 메서드에 대해서

- keys는 열거 가능한 프로퍼티 키를 배열로 반환한다.
- values는 프로퍼티의 값을 entries는 키와 값의 쌍의 배열을 배열에 담아 반환한다.

#### 48. 래퍼 객체란?

- 원시값을 객체처럼 사용하면 자바스크립트 엔진은 암묵적으로 연관된 객체를 생성하여 생성된 객체로 프로퍼티에 접근하거나 메서드를 호출하고 다시 원시값으로 되돌리는데 임시로 생성되는 객체를 래퍼 객체라고 한다.

#### 49. 전역 객체란?

- 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며, 어떤 객체에도 속하지 않은 최상위 객체이다.

#### 50. encodeURI/decodeURI

- encodeURI 함수는 완전한 URI를 문자열로 전달받아 이스케이프 처리를 위해 인코딩한다.
- 이스케이프 처리는 네트워크를 통해 정보를 공유할 때 어떤 시스템에서도 읽을 수 있는 아스키 문자 셋으로 변환하는 것이다.
- decodeURI 함수는 인코딩된 URI를 인수를 전달받아 이스케이프 처리 이전으로 디코딩한다.

- encodeURIComponent는 =,&,? 까지 인코딩한다.

#### 51. this 바인딩이 이루어지는 방식은?

- this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.
- 객체 리터럴의 메서드 내부에서의 this는 메서드를 호출한 객체를 가리키고, 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.
- 일반 함수로 호출된 모든 함수(중첩 함수, 콜백 함수 포함) 내부의 this에는 전역 객체가 바인딩된다.
- 화살표 함수 내부의 this는 상위 스코프의 this를 가리킨다.
- 메서드 내부에서 this는 메서드를 호출한 객체를 가리킨다. 
- 생성자 함수 내부에서 this는 생성자 함수가 생성할 인스턴스를 가리킨다.

#### 52. apply/call/bind

- 셋 모두 function.prototype의 메서드이기 때문에 모든 함수가 상속받아 사용가능하다.
- apply와 call은 인수를 전달하는 방식만 다르고 this를 바인딩하는 것과 함수를 호출해주는 기본적인 기능은 같다. apply는 인수를 배열 형태로 전달 받고, call은 리스트의 형태로 전달받는다. 
- bind는 함수를 호출하지 않고 this바인딩만 해준다.

#### 53. 실행컨텍스트란 무엇인가?

- 코드가 실행되려면 스코프, 식별자, 코드 실행순서 등의 관리가 필요하다.
- 소스코드를 실행하는 데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.
- 식별자와 스코프는 실행 컨텍스트의 **렉시컬 환경**으로 관리하고 코드의 실행 순서는 **실행 컨텍스트 스택**으로 관리한다.